<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        select, input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            min-width: 250px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        input[type="text"]::placeholder {
            color: #999;
            font-size: 0.9rem;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .array-container {
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 15px;
            overflow: hidden;
            flex-wrap: wrap;
        }

        .array-bubble {
            min-width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.4s ease;
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin: 2px;
            cursor: default;
            user-select: none;
        }

        .array-bubble.comparing {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.4);
            animation: pulse 0.6s ease-in-out infinite alternate;
        }

        .array-bubble.sorted {
            background: linear-gradient(135deg, #51cf66, #40c057);
            box-shadow: 0 4px 20px rgba(64, 192, 87, 0.4);
            animation: sorted-glow 0.8s ease-in-out;
        }

        .array-bubble.pivot {
            background: linear-gradient(135deg, #ffd43b, #fab005);
            box-shadow: 0 4px 20px rgba(250, 176, 5, 0.4);
            transform: scale(1.05);
            animation: pivot-spin 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1.1); }
            100% { transform: scale(1.15); }
        }

        @keyframes sorted-glow {
            0% { box-shadow: 0 4px 20px rgba(64, 192, 87, 0.4); }
            50% { box-shadow: 0 6px 30px rgba(64, 192, 87, 0.8); }
            100% { box-shadow: 0 4px 20px rgba(64, 192, 87, 0.4); }
        }

        .array-bubble.merging {
            background: linear-gradient(135deg, #9c88ff, #8c7ae6);
            box-shadow: 0 4px 20px rgba(156, 136, 255, 0.5);
            animation: merge-bounce 0.8s ease-in-out;
        }

        .array-bubble.dividing {
            background: linear-gradient(135deg, #ffa726, #ff8f00);
            box-shadow: 0 4px 20px rgba(255, 167, 38, 0.5);
            animation: divide-shake 0.6s ease-in-out;
        }

        .array-bubble.inserting {
            background: linear-gradient(135deg, #26c6da, #00acc1);
            transform: scale(1.2);
            box-shadow: 0 6px 30px rgba(38, 198, 218, 0.6);
            animation: insert-slide 0.8s ease-in-out;
        }

        .array-bubble.key-element {
            background: linear-gradient(135deg, #ab47bc, #8e24aa);
            box-shadow: 0 4px 20px rgba(171, 71, 188, 0.5);
            animation: key-highlight 1s ease-in-out infinite alternate;
        }

        .array-bubble.sorted-partition {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            box-shadow: 0 3px 15px rgba(102, 187, 106, 0.4);
        }

        @keyframes merge-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes divide-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes insert-slide {
            0% { transform: scale(1.2) translateX(-20px); opacity: 0.7; }
            50% { transform: scale(1.3) translateX(0); opacity: 1; }
            100% { transform: scale(1.2) translateX(0); opacity: 1; }
        }

        @keyframes key-highlight {
            0% { box-shadow: 0 4px 20px rgba(171, 71, 188, 0.5); }
            100% { box-shadow: 0 6px 30px rgba(171, 71, 188, 0.8); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .algorithm-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(118, 75, 162, 0.05);
            border-radius: 15px;
            text-align: center;
        }

        .complexity {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }

        .complexity-item {
            text-align: center;
        }

        .complexity-value {
            font-weight: bold;
            color: #764ba2;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
            }
            
            input[type="range"] {
                width: 200px;
            }
            
            .stats, .complexity {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ Sorting Algorithm Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Algorithm</label>
                <select id="algorithmSelect">
                    <option value="bubbleSort">Bubble Sort</option>
                    <option value="insertionSort">Insertion Sort</option>
                    <option value="selectionSort">Selection Sort</option>
                    <option value="mergeSort">Merge Sort</option>
                    <option value="quickSort">Quick Sort</option>
                    <option value="heapSort">Heap Sort</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Array Type</label>
                <select id="arrayType">
                    <option value="random">Random Array</option>
                    <option value="preset">Preset Arrays</option>
                    <option value="custom">Custom Array</option>
                </select>
            </div>

            <div class="control-group" id="arraySizeGroup">
                <label>Array Size: <span id="arraySizeValue">50</span></label>
                <input type="range" id="arraySize" min="5" max="100" value="50">
            </div>

            <div class="control-group" id="presetGroup" style="display: none;">
                <label>Preset Arrays</label>
                <select id="presetSelect">
                    <option value="sorted">Already Sorted</option>
                    <option value="reverse">Reverse Sorted</option>
                    <option value="nearly">Nearly Sorted</option>
                    <option value="duplicates">Many Duplicates</option>
                    <option value="mountain">Mountain Shape</option>
                    <option value="valley">Valley Shape</option>
                </select>
            </div>

            <div class="control-group" id="customGroup" style="display: none;">
                <label>Custom Array</label>
                <input type="text" id="customInput" placeholder="Enter numbers separated by commas (e.g., 5,2,8,1,9)" 
                       style="padding: 8px 12px; border: 2px solid #ddd; border-radius: 8px; min-width: 250px;">
            </div>
            
            <div class="control-group">
                <label>Speed: <span id="speedValue">Medium</span></label>
                <input type="range" id="speed" min="1" max="10" value="5">
            </div>
            
            <button id="generateBtn" class="btn-secondary">Generate Array</button>
            <button id="sortBtn" class="btn-primary">Start Sorting</button>
            <button id="stopBtn" class="btn-danger" disabled>Stop</button>
        </div>
        
        <div class="array-container" id="arrayContainer"></div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="comparisons">0</div>
                <div class="stat-label">Comparisons</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="swaps">0</div>
                <div class="stat-label">Swaps</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="time">0ms</div>
                <div class="stat-label">Time Elapsed</div>
            </div>
        </div>
        
        <div class="algorithm-info">
            <h3 id="algorithmName">Bubble Sort</h3>
            <p id="algorithmDescription">A simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
            <div class="complexity">
                <div class="complexity-item">
                    <div class="complexity-value" id="bestCase">O(n)</div>
                    <div>Best Case</div>
                </div>
                <div class="complexity-item">
                    <div class="complexity-value" id="averageCase">O(nÂ²)</div>
                    <div>Average Case</div>
                </div>
                <div class="complexity-item">
                    <div class="complexity-value" id="worstCase">O(nÂ²)</div>
                    <div>Worst Case</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SortingVisualizer {
            constructor() {
                this.array = [];
                this.isRunning = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                this.animationSpeed = 275;
                
                this.initializeElements();
                this.setupEventListeners();
                this.generateArray();
                this.updateAlgorithmInfo();
            }
            
            initializeElements() {
                this.arrayContainer = document.getElementById('arrayContainer');
                this.algorithmSelect = document.getElementById('algorithmSelect');
                this.arraySizeSlider = document.getElementById('arraySize');
                this.speedSlider = document.getElementById('speed');
                this.generateBtn = document.getElementById('generateBtn');
                this.sortBtn = document.getElementById('sortBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.comparisonsEl = document.getElementById('comparisons');
                this.swapsEl = document.getElementById('swaps');
                this.timeEl = document.getElementById('time');
                this.arraySizeValue = document.getElementById('arraySizeValue');
                this.speedValue = document.getElementById('speedValue');
                this.arrayTypeSelect = document.getElementById('arrayType');
                this.presetSelect = document.getElementById('presetSelect');
                this.customInput = document.getElementById('customInput');
                this.presetGroup = document.getElementById('presetGroup');
                this.customGroup = document.getElementById('customGroup');
                this.arraySizeGroup = document.getElementById('arraySizeGroup');
            }
            
            setupEventListeners() {
                this.generateBtn.addEventListener('click', () => this.generateArray());
                this.sortBtn.addEventListener('click', () => this.startSorting());
                this.stopBtn.addEventListener('click', () => this.stopSorting());
                this.algorithmSelect.addEventListener('change', () => this.updateAlgorithmInfo());
                
                this.arrayTypeSelect.addEventListener('change', (e) => {
                    this.handleArrayTypeChange(e.target.value);
                });
                
                this.arraySizeSlider.addEventListener('input', (e) => {
                    this.arraySizeValue.textContent = e.target.value;
                    if (!this.isRunning && this.arrayTypeSelect.value === 'random') {
                        this.generateArray();
                    }
                });
                
                this.speedSlider.addEventListener('input', (e) => {
                    const speeds = ['Very Slow', 'Slow', 'Slow', 'Medium', 'Medium', 'Medium', 'Fast', 'Fast', 'Very Fast', 'Lightning'];
                    this.speedValue.textContent = speeds[e.target.value - 1];
                    this.animationSpeed = 500 - (e.target.value * 45);
                });
                
                this.presetSelect.addEventListener('change', () => {
                    if (!this.isRunning && this.arrayTypeSelect.value === 'preset') {
                        this.generateArray();
                    }
                });
                
                this.customInput.addEventListener('input', () => {
                    if (!this.isRunning && this.arrayTypeSelect.value === 'custom') {
                        this.generateArray();
                    }
                });
                
                this.customInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.isRunning) {
                        this.generateArray();
                    }
                });
            }
            
            
            handleArrayTypeChange(type) {
                this.presetGroup.style.display = type === 'preset' ? 'flex' : 'none';
                this.customGroup.style.display = type === 'custom' ? 'flex' : 'none';
                this.arraySizeGroup.style.display = type === 'random' ? 'flex' : 'none';
                
                if (!this.isRunning) {
                    this.generateArray();
                }
            }
            
            generateArray() {
                if (this.isRunning) return;
                
                const arrayType = this.arrayTypeSelect.value;
                this.array = [];
                
                switch (arrayType) {
                    case 'random':
                        this.generateRandomArray();
                        break;
                    case 'preset':
                        this.generatePresetArray();
                        break;
                    case 'custom':
                        this.generateCustomArray();
                        break;
                }
                
                this.resetStats();
                this.renderArray();
            }
            
            generateRandomArray() {
                const size = Math.min(parseInt(this.arraySizeSlider.value), 25); // Limit for better bubble visualization
                for (let i = 0; i < size; i++) {
                    this.array.push(Math.floor(Math.random() * 100) + 1);
                }
                // Scale for internal processing
                this.array = this.array.map(x => x * 3);
            }
            
            generatePresetArray() {
                const preset = this.presetSelect.value;
                const size = 20; // Reduced size for better bubble visualization
                
                switch (preset) {
                    case 'sorted':
                        for (let i = 1; i <= size; i++) {
                            this.array.push(i * 3);
                        }
                        break;
                    case 'reverse':
                        for (let i = size; i >= 1; i--) {
                            this.array.push(i * 3);
                        }
                        break;
                    case 'nearly':
                        // Mostly sorted with a few out-of-place elements
                        for (let i = 1; i <= size; i++) {
                            this.array.push(i * 3);
                        }
                        // Swap a few elements
                        for (let i = 0; i < 3; i++) {
                            const idx1 = Math.floor(Math.random() * size);
                            const idx2 = Math.floor(Math.random() * size);
                            [this.array[idx1], this.array[idx2]] = [this.array[idx2], this.array[idx1]];
                        }
                        break;
                    case 'duplicates':
                        const values = [5, 10, 15, 20, 25, 30];
                        for (let i = 0; i < size; i++) {
                            this.array.push(values[Math.floor(Math.random() * values.length)] * 3);
                        }
                        break;
                    case 'mountain':
                        const mid = Math.floor(size / 2);
                        for (let i = 0; i < size; i++) {
                            if (i <= mid) {
                                this.array.push((i + 1) * 3);
                            } else {
                                this.array.push((size - i) * 3);
                            }
                        }
                        break;
                    case 'valley':
                        const midPoint = Math.floor(size / 2);
                        for (let i = 0; i < size; i++) {
                            if (i <= midPoint) {
                                this.array.push((midPoint - i + 1) * 3);
                            } else {
                                this.array.push((i - midPoint + 1) * 3);
                            }
                        }
                        break;
                }
            }
            
            generateCustomArray() {
                const input = this.customInput.value.trim();
                if (!input) {
                    // Default array if no input
                    this.array = [64, 34, 25, 12, 22, 11, 90, 5, 77, 30].map(x => x * 3);
                    return;
                }
                
                try {
                    const numbers = input.split(',').map(str => {
                        const num = parseFloat(str.trim());
                        if (isNaN(num)) {
                            throw new Error('Invalid number');
                        }
                        // Keep original numbers but scale for visualization
                        return Math.max(10, Math.abs(num) * 3);
                    });
                    
                    if (numbers.length === 0) {
                        throw new Error('No valid numbers');
                    }
                    
                    if (numbers.length > 30) {
                        // Limit array size for better bubble visualization
                        this.array = numbers.slice(0, 30);
                        this.showMessage('Array truncated to 30 elements for better visualization.');
                    } else {
                        this.array = numbers;
                    }
                } catch (error) {
                    this.showMessage('Invalid input. Please enter numbers separated by commas.');
                    this.array = [64, 34, 25, 12, 22, 11, 90, 5, 77, 30].map(x => x * 3); // Default fallback
                }
            }
            
            showMessage(text) {
                // Create temporary message
                const message = document.createElement('div');
                message.textContent = text;
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #ff6b6b;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 8px;
                    z-index: 1000;
                    font-weight: 600;
                `;
                document.body.appendChild(message);
                
                setTimeout(() => {
                    document.body.removeChild(message);
                }, 3000);
            }
            
            renderArray(highlightIndices = [], sortedIndices = [], pivotIndex = -1, specialStates = {}) {
                this.arrayContainer.innerHTML = '';
                
                this.array.forEach((value, index) => {
                    const bubble = document.createElement('div');
                    bubble.className = 'array-bubble';
                    
                    // Calculate size based on value for visual representation
                    const size = Math.max(40, Math.min(80, (value / 360) * 60 + 40));
                    bubble.style.width = `${size}px`;
                    bubble.style.height = `${size}px`;
                    bubble.style.fontSize = `${Math.max(10, size / 4)}px`;
                    
                    // Display the actual number (scaled back from visualization value)
                    const displayValue = Math.round(value / 3);
                    bubble.textContent = displayValue;
                    
                    // Apply special states for different algorithms
                    if (specialStates.merging && specialStates.merging.includes(index)) {
                        bubble.classList.add('merging');
                    } else if (specialStates.dividing && specialStates.dividing.includes(index)) {
                        bubble.classList.add('dividing');
                    } else if (specialStates.inserting && specialStates.inserting.includes(index)) {
                        bubble.classList.add('inserting');
                    } else if (specialStates.keyElement && specialStates.keyElement.includes(index)) {
                        bubble.classList.add('key-element');
                    } else if (specialStates.sortedPartition && specialStates.sortedPartition.includes(index)) {
                        bubble.classList.add('sorted-partition');
                    } else if (highlightIndices.includes(index)) {
                        bubble.classList.add('comparing');
                    } else if (sortedIndices.includes(index)) {
                        bubble.classList.add('sorted');
                    } else if (index === pivotIndex) {
                        bubble.classList.add('pivot');
                    }
                    
                    this.arrayContainer.appendChild(bubble);
                });
            }
            
            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            async swap(i, j, highlightIndices = [], specialStates = {}) {
                if (i === j) return;
                
                this.swaps++;
                this.swapsEl.textContent = this.swaps;
                
                [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                this.renderArray(highlightIndices, [], -1, specialStates);
                await this.sleep(this.animationSpeed);
            }
            
            compare() {
                this.comparisons++;
                this.comparisonsEl.textContent = this.comparisons;
            }
            
            updateStats() {
                const elapsed = Date.now() - this.startTime;
                this.timeEl.textContent = elapsed + 'ms';
            }
            
            resetStats() {
                this.comparisons = 0;
                this.swaps = 0;
                this.comparisonsEl.textContent = '0';
                this.swapsEl.textContent = '0';
                this.timeEl.textContent = '0ms';
            }
            
            async startSorting() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startTime = Date.now();
                this.sortBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.generateBtn.disabled = true;
                
                const algorithm = this.algorithmSelect.value;
                
                const updateTimer = setInterval(() => {
                    if (this.isRunning) this.updateStats();
                    else clearInterval(updateTimer);
                }, 100);
                
                try {
                    switch (algorithm) {
                        case 'bubbleSort':
                            await this.bubbleSort();
                            break;
                        case 'insertionSort':
                            await this.insertionSort();
                            break;
                        case 'selectionSort':
                            await this.selectionSort();
                            break;
                        case 'mergeSort':
                            await this.mergeSort(0, this.array.length - 1);
                            break;
                        case 'quickSort':
                            await this.quickSort(0, this.array.length - 1);
                            break;
                        case 'heapSort':
                            await this.heapSort();
                            break;
                    }
                    
                    if (this.isRunning) {
                        // Final pass to show all bars as sorted
                        this.renderArray([], Array.from({length: this.array.length}, (_, i) => i));
                    }
                } catch (error) {
                    console.error('Sorting error:', error);
                }
                
                this.stopSorting();
            }
            
            stopSorting() {
                this.isRunning = false;
                this.sortBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.generateBtn.disabled = false;
                this.updateStats();
            }
            
            async bubbleSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1 && this.isRunning; i++) {
                    for (let j = 0; j < n - i - 1 && this.isRunning; j++) {
                        this.compare();
                        this.renderArray([j, j + 1]);
                        await this.sleep(this.animationSpeed);
                        
                        if (this.array[j] > this.array[j + 1]) {
                            await this.swap(j, j + 1, [j, j + 1]);
                        }
                    }
                    this.renderArray([], Array.from({length: i + 1}, (_, k) => n - k - 1));
                }
            }
            
            async insertionSort() {
                for (let i = 1; i < this.array.length && this.isRunning; i++) {
                    let key = this.array[i];
                    let j = i - 1;
                    
                    // Show the key element being inserted
                    this.renderArray([], Array.from({length: i}, (_, k) => k), -1, {
                        keyElement: [i],
                        sortedPartition: Array.from({length: i}, (_, k) => k)
                    });
                    await this.sleep(this.animationSpeed);
                    
                    while (j >= 0 && this.isRunning) {
                        this.compare();
                        
                        // Show comparison with key element
                        this.renderArray([j], Array.from({length: i}, (_, k) => k), -1, {
                            keyElement: [i],
                            sortedPartition: Array.from({length: i}, (_, k) => k)
                        });
                        await this.sleep(this.animationSpeed);
                        
                        if (this.array[j] > key) {
                            // Show the shifting animation
                            this.array[j + 1] = this.array[j];
                            this.swaps++;
                            this.swapsEl.textContent = this.swaps;
                            
                            this.renderArray([], Array.from({length: i}, (_, k) => k), -1, {
                                inserting: [j + 1],
                                sortedPartition: Array.from({length: i}, (_, k) => k)
                            });
                            await this.sleep(this.animationSpeed);
                            
                            j--;
                        } else {
                            break;
                        }
                    }
                    
                    // Insert the key in its correct position
                    this.array[j + 1] = key;
                    
                    // Show final insertion
                    this.renderArray([], Array.from({length: i + 1}, (_, k) => k), -1, {
                        inserting: [j + 1]
                    });
                    await this.sleep(this.animationSpeed);
                    
                    // Show sorted partition growing
                    this.renderArray([], Array.from({length: i + 1}, (_, k) => k));
                    await this.sleep(this.animationSpeed / 2);
                }
            }
            
            async selectionSort() {
                for (let i = 0; i < this.array.length - 1 && this.isRunning; i++) {
                    let minIdx = i;
                    this.renderArray([i]);
                    
                    for (let j = i + 1; j < this.array.length && this.isRunning; j++) {
                        this.compare();
                        this.renderArray([minIdx, j]);
                        await this.sleep(this.animationSpeed);
                        
                        if (this.array[j] < this.array[minIdx]) {
                            minIdx = j;
                        }
                    }
                    
                    if (minIdx !== i) {
                        await this.swap(i, minIdx, [i, minIdx]);
                    }
                    
                    this.renderArray([], Array.from({length: i + 1}, (_, k) => k));
                }
            }
            
            async mergeSort(left, right) {
                if (left >= right || !this.isRunning) return;
                
                const mid = Math.floor((left + right) / 2);
                
                // Show division
                if (right - left > 1) {
                    this.renderArray([], [], -1, {
                        dividing: Array.from({length: right - left + 1}, (_, i) => left + i)
                    });
                    await this.sleep(this.animationSpeed);
                }
                
                await this.mergeSort(left, mid);
                await this.mergeSort(mid + 1, right);
                await this.merge(left, mid, right);
            }
            
            async merge(left, mid, right) {
                const leftArr = this.array.slice(left, mid + 1);
                const rightArr = this.array.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                // Show the two subarrays being merged
                this.renderArray(
                    Array.from({length: leftArr.length}, (_, idx) => left + idx)
                    .concat(Array.from({length: rightArr.length}, (_, idx) => mid + 1 + idx)),
                    [], -1, {}
                );
                await this.sleep(this.animationSpeed);
                
                while (i < leftArr.length && j < rightArr.length && this.isRunning) {
                    this.compare();
                    
                    // Highlight elements being compared from both subarrays
                    this.renderArray([left + i, mid + 1 + j], [], -1, {});
                    await this.sleep(this.animationSpeed);
                    
                    if (leftArr[i] <= rightArr[j]) {
                        this.array[k] = leftArr[i];
                        i++;
                    } else {
                        this.array[k] = rightArr[j];
                        j++;
                    }
                    
                    // Show the merging process
                    this.renderArray([], [], -1, {
                        merging: [k]
                    });
                    await this.sleep(this.animationSpeed);
                    
                    k++;
                    this.swaps++;
                    this.swapsEl.textContent = this.swaps;
                }
                
                // Handle remaining elements
                while (i < leftArr.length && this.isRunning) {
                    this.array[k] = leftArr[i];
                    this.renderArray([], [], -1, {
                        merging: [k]
                    });
                    await this.sleep(this.animationSpeed / 2);
                    i++;
                    k++;
                }
                
                while (j < rightArr.length && this.isRunning) {
                    this.array[k] = rightArr[j];
                    this.renderArray([], [], -1, {
                        merging: [k]
                    });
                    await this.sleep(this.animationSpeed / 2);
                    j++;
                    k++;
                }
                
                // Show the completed merge
                this.renderArray([], [], -1, {
                    sortedPartition: Array.from({length: right - left + 1}, (_, idx) => left + idx)
                });
                await this.sleep(this.animationSpeed);
            }
            
            async quickSort(low, high) {
                if (low < high && this.isRunning) {
                    const pi = await this.partition(low, high);
                    await this.quickSort(low, pi - 1);
                    await this.quickSort(pi + 1, high);
                }
            }
            
            async partition(low, high) {
                const pivot = this.array[high];
                let i = low - 1;
                
                for (let j = low; j < high && this.isRunning; j++) {
                    this.compare();
                    this.renderArray([j], [], high);
                    await this.sleep(this.animationSpeed);
                    
                    if (this.array[j] < pivot) {
                        i++;
                        await this.swap(i, j, [i, j]);
                    }
                }
                
                await this.swap(i + 1, high, [i + 1, high]);
                return i + 1;
            }
            
            async heapSort() {
                const n = this.array.length;
                
                // Build heap
                for (let i = Math.floor(n / 2) - 1; i >= 0 && this.isRunning; i--) {
                    await this.heapify(n, i);
                }
                
                // Extract elements from heap one by one
                for (let i = n - 1; i > 0 && this.isRunning; i--) {
                    await this.swap(0, i, [0, i]);
                    await this.heapify(i, 0);
                    this.renderArray([], Array.from({length: n - i}, (_, k) => n - k - 1));
                }
            }
            
            async heapify(n, i) {
                let largest = i;
                let left = 2 * i + 1;
                let right = 2 * i + 2;
                
                if (left < n) {
                    this.compare();
                    this.renderArray([left, largest]);
                    await this.sleep(this.animationSpeed);
                    
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                    }
                }
                
                if (right < n) {
                    this.compare();
                    this.renderArray([right, largest]);
                    await this.sleep(this.animationSpeed);
                    
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                    }
                }
                
                if (largest !== i) {
                    await this.swap(i, largest, [i, largest]);
                    await this.heapify(n, largest);
                }
            }
            
            updateAlgorithmInfo() {
                const algorithm = this.algorithmSelect.value;
                const info = {
                    bubbleSort: {
                        name: 'Bubble Sort',
                        description: 'A simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
                        best: 'O(n)',
                        average: 'O(nÂ²)',
                        worst: 'O(nÂ²)'
                    },
                    insertionSort: {
                        name: 'Insertion Sort',
                        description: 'Builds the final sorted array one item at a time. It is efficient for small data sets and adaptive for data sets that are already substantially sorted.',
                        best: 'O(n)',
                        average: 'O(nÂ²)',
                        worst: 'O(nÂ²)'
                    },
                    selectionSort: {
                        name: 'Selection Sort',
                        description: 'Divides the list into sorted and unsorted regions, and repeatedly selects the smallest element from the unsorted region.',
                        best: 'O(nÂ²)',
                        average: 'O(nÂ²)',
                        worst: 'O(nÂ²)'
                    },
                    mergeSort: {
                        name: 'Merge Sort',
                        description: 'A divide-and-conquer algorithm that divides the array into halves, sorts them, and then merges them back together.',
                        best: 'O(n log n)',
                        average: 'O(n log n)',
                        worst: 'O(n log n)'
                    },
                    quickSort: {
                        name: 'Quick Sort',
                        description: 'A divide-and-conquer algorithm that picks a pivot element and partitions the array around the pivot.',
                        best: 'O(n log n)',
                        average: 'O(n log n)',
                        worst: 'O(nÂ²)'
                    },
                    heapSort: {
                        name: 'Heap Sort',
                        description: 'Uses a binary heap data structure to sort elements. It builds a max heap and repeatedly extracts the maximum element.',
                        best: 'O(n log n)',
                        average: 'O(n log n)',
                        worst: 'O(n log n)'
                    }
                };
                
                const current = info[algorithm];
                document.getElementById('algorithmName').textContent = current.name;
                document.getElementById('algorithmDescription').textContent = current.description;
                document.getElementById('bestCase').textContent = current.best;
                document.getElementById('averageCase').textContent = current.average;
                document.getElementById('worstCase').textContent = current.worst;
            }
        }
        
        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SortingVisualizer();
        });
    </script>
</body>
</html>
